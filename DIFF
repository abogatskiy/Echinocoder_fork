4c4
< # This is re-implemented in C0_bug2_numpy_simplicialComplex_encoder_for_array_of_reals_as_multiset.py as a single list comprehension
---
> # This is a re-implementation of C0_bug1_numpy_simplicialComplex_encoder_for_array_of_reals_as_multiset.py using a single list comprehension
8a9,10
> from itertools import pairwise
> 
165,173c167,184
< def map_Delta_k_to_the_n_to_c_dc_pairs(#n=3,k=3,  # Only need n and/or k if doing "original initialisation" of x_with_coeffs 
<          delta, # Each key in the dict is an (j,i) tuple representing Patrick's e^j_i with j in [0,n-1] and i in [0,k-1].  The associated value is the coefficient of that e^j_i basis vector in the associated element of (\Delta_k)^n.
<         # e.g delta = {  
<         #     (0,0) : 0.5, (0,1) : 0.2, (0,2) : 0.1,    #a point in the 1st simplex (simplex 0)
<         #     (1,2) : 0.25,                             #a point in the 2nd simplex (simplex 1)
<         #     (2,0) : 0.1,                              #a point in the 3rd simplex (simplex 2)
<         #   }, 
<         ):
<     delta = delta.copy() # because we heavily modify internally and dicts are mutable!
<     c_dc_pairs = []
<     if False:
<         # Original initialisation. If using this pass n and k to the algorithm
<         # Set up initial value of x based on n, k and delta.
<         # This is the only place where n or k is used.
<         x_with_coeffs = {  (j,k-1):delta.get((j,k-1),0)  for j in range(n) } 
<     else:
<         # n-and-k-independent initialisation
<         if delta:
<            j_vals = {j for (j,i) in delta.keys() }
<            largest_j = max(j_vals)
<            largest_i_for_j = {  j:max([ i for (jj,i) in delta.keys() if jj == j ])   for j in j_vals }
<            x_with_coeffs = {  (j,largest_i_for_j[j]):delta[(j,largest_i_for_j[j])]  for j in j_vals } 
<         else:
<            x_with_coeffs = dict()
<     while x_with_coeffs:
<         #print("Iteration! =====")
<         #print("delta",delta)
<         #print("x_with_coeffs",x_with_coeffs)
<         e = min(x_with_coeffs, key=x_with_coeffs.get)
<         dx = x_with_coeffs[e]
<         z=e[0] # z is the j-val of the element of x with the smallest coefficient
<         #print("smallest: e=",e,"coeff=",dx, "z=",z)
<         if dx<0:
<             # dx should never be negative.
<             print("ERROR: or unexpected numerical precision concern since dx=",dx,"<0.")
<             raise Exception("IMPLEMENTATION ERROR")
<         if dx>0:
<             # Grow the c_dc_pairs list
<             c = list(x_with_coeffs.keys()) # could use list or set in the implementation ... it doesn't really matter ... but the object represented is a set
<             c_dc_pairs.append((c, dx)) 
<             #print("grew c_dc_pairs")
<             #print("c_dc_pairs=",c_dc_pairs)
<             # trim delta
<             for pair,val in list(delta.items()):
<                  if pair in c:
<                      if val == dx:
<                         del delta[pair]
<                      elif val>dx:
<                         delta[pair] = val-dx
<                      else:
<                         print("ERROR: val=",val,"dx=",dx)
<                         raise Exception("IMPLEMENTATION ERROR! Should not have val<dx.")
<         # trim and update x_with_coeffs:
<         del x_with_coeffs[e] # since this part should be gone.  Needed by next line!
<         # Set up new keys:
<         new_keys = list(x_with_coeffs.keys()) # Will not contain e.
<         if e[1]>0:
<             new_e = (z, e[1]-1)
<             new_keys.append(new_e)
<         # refresh x_with_coeffs:
<         x_with_coeffs = { new_key:delta.get(new_key,0)  for new_key in new_keys } 
<            
<     # We are done:        
<     c_dc_pairs = map_Delta_k_to_the_n_to_c_dc_pairs(delta=delta)
<     return c_dc_pairs

> def make_flat_sums(n,k,delta, sort=False, prepend_zero=False)
>     flat_sums=list([ (j, tuple(range(i_min, k)), sum([delta.get((j,i), 0) for i in range(i_min,k) ])) for j in range(n) for i_min in range(k) ])
>     #print("flat_sums unsorted",flat_sums)
>     if sort:
>         flat_sums = sorted(flat_sums, key=lambda x : (x[2], len(x[1])) ) # Sort by delta sum, but break ties in favour of longer sums
>         #print("flat_sums sorted",flat_sums)
>     if prepend_zero:
>         flat_sums = [ ( None, tuple(), 0) ] + flat_sums
>     return flat_sums
> 
> def map_Delta_k_to_the_n_to_c_dc_pairs(n , k,  # Only need n and/or k if doing "original initialisation" of x_with_coeffs 
>          delta, prune_zeros = True,  # False is recommended default! See comments below.
>         ):
> 
>     # Pruning zeros is optional as they are technically unnecessasry. However, removing them may also destroy regularity/predictability
>     # e.g. people might prefer to see c_dc_pairs always have the same length as the number of non-origin simplex points. 
>     # It is also a test on a floating point number, which is a bit silly.  Default should therefore be NOT pruning zeros.
> 
>     flat_sums = make_flat_sums(n,k,delta, sort=True)
>
>     dc_vals = [ sum2-sum1 for (j1,i1_vals, sum1),(j2,i2_vals, sum2) in pairwise([(None, tuple(), 0), ]+flat_sums) ]
> 
>     c_dc_pairs = [ ([ (j,max(moo)) for j in range(n) if (moo:=[ min(iis) for (jj,iis,_) in flat_sums[index:] if jj == j ]) ], dc_vals[index]) for index in range(len(flat_sums)) if not prune_zeros or dc_vals[index] != 0 ]
>     return c_dc_pairs
